{"ast":null,"code":"import _objectSpread from \"F:/SE FD BD MAD/React/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"F:/SE FD BD MAD/React/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"transition\", \"transitionEnd\"];\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return animations => Promise.all(animations.map(_ref => {\n    let {\n      animation,\n      options\n    } = _ref;\n    return animateVisualElement(visualElement, animation, options);\n  }));\n}\nfunction createAnimationState(visualElement) {\n  let animate = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  /**\r\n   * This function will be used to reduce the animation definitions for\r\n   * each active animation type into an object of resolved values for it.\r\n   */\n  const buildResolvedTypeValues = (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      const {\n          transition,\n          transitionEnd\n        } = resolved,\n        target = _objectWithoutProperties(resolved, _excluded);\n      acc = _objectSpread(_objectSpread(_objectSpread({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  /**\r\n   * This just allows us to inject mocked animation functions\r\n   * @internal\r\n   */\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\r\n   * When we receive new props, we need to:\r\n   * 1. Create a list of protected keys for each type. This is a directory of\r\n   *    value keys that are currently being \"handled\" by types of a higher priority\r\n   *    so that whenever an animation is played of a given type, these values are\r\n   *    protected from being animated.\r\n   * 2. Determine if an animation type needs animating.\r\n   * 3. Determine if any values have been removed from a type and figure out\r\n   *    what to animate those to.\r\n   */\n  function animateChanges(options, changedActiveType) {\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    /**\r\n     * A list of animations that we'll build into as we iterate through the animation\r\n     * types. This will get executed at the end of the function.\r\n     */\n    const animations = [];\n    /**\r\n     * Keep track of which values have been removed. Then, as we hit lower priority\r\n     * animation types, we can check if they contain removed values and animate to that.\r\n     */\n    const removedKeys = new Set();\n    /**\r\n     * A dictionary of all encountered keys. This is an object to let us build into and\r\n     * copy it without iteration. Each time we hit an animation type we set its protected\r\n     * keys - the keys its not allowed to animate - to the latest version of this object.\r\n     */\n    let encounteredKeys = {};\n    /**\r\n     * If a variant has been removed at a given index, and this component is controlling\r\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n     */\n    let removedVariantIndex = Infinity;\n    /**\r\n     * Iterate through all animation types in reverse priority order. For each, we want to\r\n     * detect which values it's handling and whether or not they've changed (and therefore\r\n     * need to be animated). If any values have been removed, we want to detect those in\r\n     * lower priority props and flag for animation.\r\n     */\n    for (let i = 0; i < numAnimationTypes; i++) {\n      const type = reversePriorityOrder[i];\n      const typeState = state[type];\n      const prop = props[type] !== undefined ? props[type] : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      /**\r\n       * If this type has *just* changed isActive status, set activeDelta\r\n       * to that status. Otherwise set to null.\r\n       */\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\r\n       * If this prop is an inherited variant, rather than been set directly on the\r\n       * component itself, we want to make sure we allow the parent to trigger animations.\r\n       *\r\n       * TODO: Can probably change this to a !isControllingVariants check\r\n       */\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\r\n       *\r\n       */\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\r\n       * Set all encountered keys so far as the protected keys for this type. This will\r\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n       */\n      typeState.protectedKeys = _objectSpread({}, encounteredKeys);\n      // Check if we can skip analysing this prop early\n      if (\n      // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null ||\n      // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp ||\n      // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      /**\r\n       * As we go look through the values defined on this type, if we detect\r\n       * a changed value or a value that was removed in a higher priority, we set\r\n       * this to true and add this prop to the animation list.\r\n       */\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange ||\n      // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||\n      // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      let handledRemovedValues = false;\n      /**\r\n       * As animations can be set as variant lists, variants or target objects, we\r\n       * coerce everything to an array if it isn't one already\r\n       */\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\r\n       * Build an object of all the resolved values. We'll use this in the subsequent\r\n       * animateChanges calls to determine whether a value has changed.\r\n       */\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\r\n       * Now we need to loop through all the keys in the prev prop and this prop,\r\n       * and decide:\r\n       * 1. If the value has changed, and needs animating\r\n       * 2. If it has been removed, and needs adding to the removedKeys set\r\n       * 3. If it has been removed in a higher priority type and needs animating\r\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n       *    needs adding to the type's protectedKeys list.\r\n       */\n      const {\n        prevResolvedValues = {}\n      } = typeState;\n      const allKeys = _objectSpread(_objectSpread({}, prevResolvedValues), resolvedValues);\n      const markToAnimate = key => {\n        shouldAnimateType = true;\n        if (removedKeys.has(key)) {\n          handledRemovedValues = true;\n          removedKeys.delete(key);\n        }\n        typeState.needsAnimating[key] = true;\n      };\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key];\n        // If we've already handled this we can just skip ahead\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\r\n         * If the value has changed, we probably want to animate it.\r\n         */\n        let valueHasChanged = false;\n        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n          valueHasChanged = !shallowCompare(next, prev);\n        } else {\n          valueHasChanged = next !== prev;\n        }\n        if (valueHasChanged) {\n          if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\r\n           * If next hasn't changed and it isn't undefined, we want to check if it's\r\n           * been removed by a higher priority\r\n           */\n          markToAnimate(key);\n        } else {\n          /**\r\n           * If it hasn't changed, we add it to the list of protected values\r\n           * to ensure it doesn't get animated.\r\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\r\n       * Update the typeState so next time animateChanges is called we can compare the\r\n       * latest prop and resolvedValues to these.\r\n       */\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\r\n       *\r\n       */\n      if (typeState.isActive) {\n        encounteredKeys = _objectSpread(_objectSpread({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\r\n       * If this is an inherited prop we want to hard-block animations\r\n       */\n      if (shouldAnimateType && (!isInherited || handledRemovedValues)) {\n        animations.push(...definitionList.map(animation => ({\n          animation: animation,\n          options: _objectSpread({\n            type\n          }, options)\n        })));\n      }\n    }\n    /**\r\n     * If there are some removed value that haven't been dealt with,\r\n     * we need to create a new animation that falls back either to the value\r\n     * defined in the style prop, or the last read value.\r\n     */\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach(key => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation\n      });\n    }\n    let shouldAnimate = Boolean(animations.length);\n    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\r\n   * Change whether a certain animation type is active.\r\n   */\n  function setActive(type, isActive, options) {\n    var _a;\n    // If the active state hasn't changed, we can safely do nothing here\n    if (state[type].isActive === isActive) return Promise.resolve();\n    // Propagate active change to children\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(child => {\n      var _a;\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations = animateChanges(options, type);\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations;\n  }\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState() {\n  let isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    animate: createTypeState(true),\n    whileInView: createTypeState(),\n    whileHover: createTypeState(),\n    whileTap: createTypeState(),\n    whileDrag: createTypeState(),\n    whileFocus: createTypeState(),\n    exit: createTypeState()\n  };\n}\nexport { checkVariantsDidChange, createAnimationState };","map":{"version":3,"names":["isAnimationControls","isKeyframesTarget","shallowCompare","isVariantLabel","resolveVariant","variantPriorityOrder","animateVisualElement","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","_ref","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","acc","definition","resolved","transition","transitionEnd","target","_objectWithoutProperties","_excluded","_objectSpread","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","getProps","context","getVariantContext","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","type","typeState","prop","undefined","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","next","prev","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","_a","variantChildren","child","animationState","getState","createTypeState","arguments","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"sources":["F:/SE FD BD MAD/React/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\r\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\nimport { variantPriorityOrder } from './variant-props.mjs';\r\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\r\n\r\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\r\nconst numAnimationTypes = variantPriorityOrder.length;\r\nfunction animateList(visualElement) {\r\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\r\n}\r\nfunction createAnimationState(visualElement) {\r\n    let animate = animateList(visualElement);\r\n    const state = createState();\r\n    let isInitialRender = true;\r\n    /**\r\n     * This function will be used to reduce the animation definitions for\r\n     * each active animation type into an object of resolved values for it.\r\n     */\r\n    const buildResolvedTypeValues = (acc, definition) => {\r\n        const resolved = resolveVariant(visualElement, definition);\r\n        if (resolved) {\r\n            const { transition, transitionEnd, ...target } = resolved;\r\n            acc = { ...acc, ...target, ...transitionEnd };\r\n        }\r\n        return acc;\r\n    };\r\n    /**\r\n     * This just allows us to inject mocked animation functions\r\n     * @internal\r\n     */\r\n    function setAnimateFunction(makeAnimator) {\r\n        animate = makeAnimator(visualElement);\r\n    }\r\n    /**\r\n     * When we receive new props, we need to:\r\n     * 1. Create a list of protected keys for each type. This is a directory of\r\n     *    value keys that are currently being \"handled\" by types of a higher priority\r\n     *    so that whenever an animation is played of a given type, these values are\r\n     *    protected from being animated.\r\n     * 2. Determine if an animation type needs animating.\r\n     * 3. Determine if any values have been removed from a type and figure out\r\n     *    what to animate those to.\r\n     */\r\n    function animateChanges(options, changedActiveType) {\r\n        const props = visualElement.getProps();\r\n        const context = visualElement.getVariantContext(true) || {};\r\n        /**\r\n         * A list of animations that we'll build into as we iterate through the animation\r\n         * types. This will get executed at the end of the function.\r\n         */\r\n        const animations = [];\r\n        /**\r\n         * Keep track of which values have been removed. Then, as we hit lower priority\r\n         * animation types, we can check if they contain removed values and animate to that.\r\n         */\r\n        const removedKeys = new Set();\r\n        /**\r\n         * A dictionary of all encountered keys. This is an object to let us build into and\r\n         * copy it without iteration. Each time we hit an animation type we set its protected\r\n         * keys - the keys its not allowed to animate - to the latest version of this object.\r\n         */\r\n        let encounteredKeys = {};\r\n        /**\r\n         * If a variant has been removed at a given index, and this component is controlling\r\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n         */\r\n        let removedVariantIndex = Infinity;\r\n        /**\r\n         * Iterate through all animation types in reverse priority order. For each, we want to\r\n         * detect which values it's handling and whether or not they've changed (and therefore\r\n         * need to be animated). If any values have been removed, we want to detect those in\r\n         * lower priority props and flag for animation.\r\n         */\r\n        for (let i = 0; i < numAnimationTypes; i++) {\r\n            const type = reversePriorityOrder[i];\r\n            const typeState = state[type];\r\n            const prop = props[type] !== undefined ? props[type] : context[type];\r\n            const propIsVariant = isVariantLabel(prop);\r\n            /**\r\n             * If this type has *just* changed isActive status, set activeDelta\r\n             * to that status. Otherwise set to null.\r\n             */\r\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\r\n            if (activeDelta === false)\r\n                removedVariantIndex = i;\r\n            /**\r\n             * If this prop is an inherited variant, rather than been set directly on the\r\n             * component itself, we want to make sure we allow the parent to trigger animations.\r\n             *\r\n             * TODO: Can probably change this to a !isControllingVariants check\r\n             */\r\n            let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\r\n            /**\r\n             *\r\n             */\r\n            if (isInherited &&\r\n                isInitialRender &&\r\n                visualElement.manuallyAnimateOnMount) {\r\n                isInherited = false;\r\n            }\r\n            /**\r\n             * Set all encountered keys so far as the protected keys for this type. This will\r\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n             */\r\n            typeState.protectedKeys = { ...encounteredKeys };\r\n            // Check if we can skip analysing this prop early\r\n            if (\r\n            // If it isn't active and hasn't *just* been set as inactive\r\n            (!typeState.isActive && activeDelta === null) ||\r\n                // If we didn't and don't have any defined prop for this animation type\r\n                (!prop && !typeState.prevProp) ||\r\n                // Or if the prop doesn't define an animation\r\n                isAnimationControls(prop) ||\r\n                typeof prop === \"boolean\") {\r\n                continue;\r\n            }\r\n            /**\r\n             * As we go look through the values defined on this type, if we detect\r\n             * a changed value or a value that was removed in a higher priority, we set\r\n             * this to true and add this prop to the animation list.\r\n             */\r\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\r\n            let shouldAnimateType = variantDidChange ||\r\n                // If we're making this variant active, we want to always make it active\r\n                (type === changedActiveType &&\r\n                    typeState.isActive &&\r\n                    !isInherited &&\r\n                    propIsVariant) ||\r\n                // If we removed a higher-priority variant (i is in reverse order)\r\n                (i > removedVariantIndex && propIsVariant);\r\n            let handledRemovedValues = false;\r\n            /**\r\n             * As animations can be set as variant lists, variants or target objects, we\r\n             * coerce everything to an array if it isn't one already\r\n             */\r\n            const definitionList = Array.isArray(prop) ? prop : [prop];\r\n            /**\r\n             * Build an object of all the resolved values. We'll use this in the subsequent\r\n             * animateChanges calls to determine whether a value has changed.\r\n             */\r\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\r\n            if (activeDelta === false)\r\n                resolvedValues = {};\r\n            /**\r\n             * Now we need to loop through all the keys in the prev prop and this prop,\r\n             * and decide:\r\n             * 1. If the value has changed, and needs animating\r\n             * 2. If it has been removed, and needs adding to the removedKeys set\r\n             * 3. If it has been removed in a higher priority type and needs animating\r\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n             *    needs adding to the type's protectedKeys list.\r\n             */\r\n            const { prevResolvedValues = {} } = typeState;\r\n            const allKeys = {\r\n                ...prevResolvedValues,\r\n                ...resolvedValues,\r\n            };\r\n            const markToAnimate = (key) => {\r\n                shouldAnimateType = true;\r\n                if (removedKeys.has(key)) {\r\n                    handledRemovedValues = true;\r\n                    removedKeys.delete(key);\r\n                }\r\n                typeState.needsAnimating[key] = true;\r\n            };\r\n            for (const key in allKeys) {\r\n                const next = resolvedValues[key];\r\n                const prev = prevResolvedValues[key];\r\n                // If we've already handled this we can just skip ahead\r\n                if (encounteredKeys.hasOwnProperty(key))\r\n                    continue;\r\n                /**\r\n                 * If the value has changed, we probably want to animate it.\r\n                 */\r\n                let valueHasChanged = false;\r\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\r\n                    valueHasChanged = !shallowCompare(next, prev);\r\n                }\r\n                else {\r\n                    valueHasChanged = next !== prev;\r\n                }\r\n                if (valueHasChanged) {\r\n                    if (next !== undefined) {\r\n                        // If next is defined and doesn't equal prev, it needs animating\r\n                        markToAnimate(key);\r\n                    }\r\n                    else {\r\n                        // If it's undefined, it's been removed.\r\n                        removedKeys.add(key);\r\n                    }\r\n                }\r\n                else if (next !== undefined && removedKeys.has(key)) {\r\n                    /**\r\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\r\n                     * been removed by a higher priority\r\n                     */\r\n                    markToAnimate(key);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If it hasn't changed, we add it to the list of protected values\r\n                     * to ensure it doesn't get animated.\r\n                     */\r\n                    typeState.protectedKeys[key] = true;\r\n                }\r\n            }\r\n            /**\r\n             * Update the typeState so next time animateChanges is called we can compare the\r\n             * latest prop and resolvedValues to these.\r\n             */\r\n            typeState.prevProp = prop;\r\n            typeState.prevResolvedValues = resolvedValues;\r\n            /**\r\n             *\r\n             */\r\n            if (typeState.isActive) {\r\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\r\n            }\r\n            if (isInitialRender && visualElement.blockInitialAnimation) {\r\n                shouldAnimateType = false;\r\n            }\r\n            /**\r\n             * If this is an inherited prop we want to hard-block animations\r\n             */\r\n            if (shouldAnimateType && (!isInherited || handledRemovedValues)) {\r\n                animations.push(...definitionList.map((animation) => ({\r\n                    animation: animation,\r\n                    options: { type, ...options },\r\n                })));\r\n            }\r\n        }\r\n        /**\r\n         * If there are some removed value that haven't been dealt with,\r\n         * we need to create a new animation that falls back either to the value\r\n         * defined in the style prop, or the last read value.\r\n         */\r\n        if (removedKeys.size) {\r\n            const fallbackAnimation = {};\r\n            removedKeys.forEach((key) => {\r\n                const fallbackTarget = visualElement.getBaseTarget(key);\r\n                if (fallbackTarget !== undefined) {\r\n                    fallbackAnimation[key] = fallbackTarget;\r\n                }\r\n            });\r\n            animations.push({ animation: fallbackAnimation });\r\n        }\r\n        let shouldAnimate = Boolean(animations.length);\r\n        if (isInitialRender &&\r\n            (props.initial === false || props.initial === props.animate) &&\r\n            !visualElement.manuallyAnimateOnMount) {\r\n            shouldAnimate = false;\r\n        }\r\n        isInitialRender = false;\r\n        return shouldAnimate ? animate(animations) : Promise.resolve();\r\n    }\r\n    /**\r\n     * Change whether a certain animation type is active.\r\n     */\r\n    function setActive(type, isActive, options) {\r\n        var _a;\r\n        // If the active state hasn't changed, we can safely do nothing here\r\n        if (state[type].isActive === isActive)\r\n            return Promise.resolve();\r\n        // Propagate active change to children\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\r\n        state[type].isActive = isActive;\r\n        const animations = animateChanges(options, type);\r\n        for (const key in state) {\r\n            state[key].protectedKeys = {};\r\n        }\r\n        return animations;\r\n    }\r\n    return {\r\n        animateChanges,\r\n        setActive,\r\n        setAnimateFunction,\r\n        getState: () => state,\r\n    };\r\n}\r\nfunction checkVariantsDidChange(prev, next) {\r\n    if (typeof next === \"string\") {\r\n        return next !== prev;\r\n    }\r\n    else if (Array.isArray(next)) {\r\n        return !shallowCompare(next, prev);\r\n    }\r\n    return false;\r\n}\r\nfunction createTypeState(isActive = false) {\r\n    return {\r\n        isActive,\r\n        protectedKeys: {},\r\n        needsAnimating: {},\r\n        prevResolvedValues: {},\r\n    };\r\n}\r\nfunction createState() {\r\n    return {\r\n        animate: createTypeState(true),\r\n        whileInView: createTypeState(),\r\n        whileHover: createTypeState(),\r\n        whileTap: createTypeState(),\r\n        whileDrag: createTypeState(),\r\n        whileFocus: createTypeState(),\r\n        exit: createTypeState(),\r\n    };\r\n}\r\n\r\nexport { checkVariantsDidChange, createAnimationState };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}